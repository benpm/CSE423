%{
    #include <vector>
    #include <spdlog/spdlog.h>
    #include <spdlog/sinks/stdout_color_sinks.h>
    #include <spdlog/fmt/fmt.h>
    #include <parsetree.hpp>

    extern int yylex();
    extern int yyparse();

    void yyerror(const char *s);

    PTNode* pt;
%}
%locations
%define parse.error verbose

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  Initially (by default), yystype
// is merely a typedef of "int", but for non-trivial projects, tokens could
// be of any arbitrary data type.  So, to deal with that, the idea is to
// override yystype's default typedef to be a C union instead.  Unions can
// hold all of the types of tokens that Flex could return, and this this means
// we can return ints or floats or strings cleanly.  Bison implements this
// mechanism with the %union directive:
%union {
    int ival;
    float fval;
    char *sval;
    char cval;
    PTNode* pt;
}

// Non-Terminal symbols
%type <pt> program
%type <pt> declarationList
%type <pt> declaration
%type <pt> varDeclaration
%type <pt> scopedVarDeclaration
%type <pt> varDeclList
%type <pt> varDeclInitialize
%type <pt> varDeclId
%type <pt> scopedTypeSpecifier
%type <pt> typeSpecifier
%type <pt> funDeclaration
%type <pt> funName
%type <pt> params
%type <pt> paramList
%type <pt> paramId
%type <pt> statement
%type <pt> expressionStmt
%type <pt> expression
%type <pt> mutable
%type <pt> assignop
%type <pt> unaryAssignop
%type <pt> simpleExpression
%type <pt> andExpression
%type <pt> unaryRelExpression
%type <pt> unaryAssignExpr
%type <pt> relExpression
%type <pt> relop
%type <pt> sumExpression
%type <pt> sumop
%type <pt> mulExpression
%type <pt> mulop
%type <pt> unaryExpression
%type <pt> factor
%type <pt> immutable
%type <pt> call
%type <pt> args
%type <pt> argList
%type <pt> constant
%type <pt> compoundStmt
%type <pt> localDeclarations
%type <pt> statementList
%type <pt> selectionStmt
%type <pt> elseIfList
%type <pt> iterationStmt
%type <pt> whileStmt
%type <pt> forStmt
%type <pt> returnStmt
%type <pt> breakStmt
%type <pt> elseStmt
%type <pt> unaryMinus

//Terminal symbols
%token <sval> INT
%token <sval> FLOAT
%token <sval> CHAR

%token <sval> FOR
%token <sval> WHILE
%token <sval> IF
%token <sval> ELSE
%token <sval> RETURN
%token <sval> BREAK

%token <cval> SEMICOLON
%token <cval> COMMA
%token <cval> LPAREN
%token <cval> RPAREN
%token <cval> LBRACE
%token <cval> RBRACE
%token <cval> LBRACK
%token <cval> RBRACK
%token <cval> EQUAL
%token <cval> PLUS
%token <cval> MINUS
%token <cval> TIMES
%token <cval> DIVIDE
%token <cval> MODULO
%token <sval> PLUSEQUAL
%token <sval> MINUSEQUAL
%token <sval> TIMESEQUAL
%token <sval> DIVEQUAL
%token <sval> MODEQUAL
%token <sval> INCR
%token <sval> DECR
%token <cval> LT
%token <cval> GT
%token <sval> LE
%token <sval> GE
%token <sval> ISEQ
%token <sval> NOTEQ
%token <sval> LOGAND
%token <sval> LOGOR
%token <cval> NOT

%token <sval> STRINGLIT
%token <cval> CHARLIT
%token <ival> INTCONST
%token <fval> FLOATCONST
%token <sval> ID

%token <sval> UNKNOWN

// Grammar productions
%%
program:
    declarationList
        {
            pt = new PTNode(PTNode::PROGRAM,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
declarationList:
    declarationList declaration
        {
            $$ = new PTNode(PTNode::DECLARATION_LIST,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
    | declaration
        {
            $$ = new PTNode(PTNode::DECLARATION_LIST,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
declaration:
    varDeclaration
        {
            $$ = new PTNode(PTNode::DECLARATION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | funDeclaration
        {
            $$ = new PTNode(PTNode::DECLARATION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
varDeclaration:
    typeSpecifier varDeclList SEMICOLON
        {
            $$ = new PTNode(PTNode::VAR_DECLARATION,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
;
scopedVarDeclaration:
    scopedTypeSpecifier varDeclList SEMICOLON
        {
            $$ = new PTNode(PTNode::SCOPED_VAR_DECLARATION,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
;
varDeclList:
    varDeclList COMMA varDeclInitialize
        {
            $$ = new PTNode(PTNode::VAR_DECL_LIST,
                std::vector<PTNode*> { $1, $3 }, yylloc.first_line);
        }
    | varDeclInitialize
        {
            $$ = new PTNode(PTNode::VAR_DECL_LIST,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
varDeclInitialize:
    varDeclId
        {
            $$ = new PTNode(PTNode::VAR_DECL_INITIALIZE,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | varDeclId EQUAL simpleExpression
        {
            PTNode *nEQUAL = new PTNode(PTNode::EQUAL, yylloc.first_line);
            $$ = new PTNode(PTNode::VAR_DECL_INITIALIZE,
                std::vector<PTNode*> { $1, nEQUAL, $3}, yylloc.first_line);
        }
;
varDeclId:
    ID
        {
            $$ = new PTNode(PTNode::ID, yylloc.first_line);
            $$->data.sval = $1;
        }
    | ID LBRACK RBRACK
        {
            $$ = new PTNode(PTNode::ARRAY_ID, yylloc.first_line);
        }
    | ID LBRACK constant RBRACK
        {
            $$ = new PTNode(PTNode::VAR_DECL_ID,
                std::vector<PTNode*> { $3 }, yylloc.first_line);
        }
;
scopedTypeSpecifier:
    typeSpecifier
        {
            $$ = new PTNode(PTNode::SCOPED_TYPE_SPECIFIER,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
typeSpecifier:
    INT
        {
            $$ = new PTNode(PTNode::INT, yylloc.first_line);
        }
    | FLOAT
        {
            $$ = new PTNode(PTNode::FLOAT, yylloc.first_line);
        }
    | CHAR
        {
            $$ = new PTNode(PTNode::CHAR, yylloc.first_line);
        }
;
funName:
    ID
        {
            $$ = new PTNode(PTNode::ID, yylloc.first_line);
            $$->data.sval = $1;
        }
;
funDeclaration:
    typeSpecifier funName LPAREN params RPAREN statement
        {
            $$ = new PTNode(PTNode::FUN_DECLARATION,
                std::vector<PTNode*> { $1, $2, $4, $6}, yylloc.first_line);
        }
;
params:
    paramList
        {
            $$ = new PTNode(PTNode::PARAMS,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | %empty
        {
            $$ = new PTNode(PTNode::PARAMS, yylloc.first_line);
        }
;
paramList:
    paramList COMMA typeSpecifier paramId
        {
            $$ = new PTNode(PTNode::PARAM_LIST,
                std::vector<PTNode*> { $1, $3, $4 }, yylloc.first_line);
        }
    | typeSpecifier paramId
        {
            $$ = new PTNode(PTNode::PARAM_LIST,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
;
paramId:
    ID
        {
            $$ = new PTNode(PTNode::ID, yylloc.first_line);
            $$->data.sval = $1;
        }
    | ID LBRACK RBRACK
        {
            $$ = new PTNode(PTNode::ID, yylloc.first_line);
            $$->data.sval = $1;
        }
;
statement:
    expressionStmt
        {
            $$ = new PTNode(PTNode::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | compoundStmt
        {
            $$ = new PTNode(PTNode::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | selectionStmt
        {
            $$ = new PTNode(PTNode::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | iterationStmt
        {
            $$ = new PTNode(PTNode::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | returnStmt
        {
            $$ = new PTNode(PTNode::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | breakStmt
        {
            $$ = new PTNode(PTNode::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
expressionStmt:
    expression SEMICOLON
        {
            $$ = new PTNode(PTNode::EXPRESSION_STMT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | SEMICOLON
        {
            $$ = new PTNode();
        }
;
expression:
    mutable assignop expression
        {
            $$ = new PTNode(PTNode::EXPRESSION,
                std::vector<PTNode*> { $1, $2, $3 }, yylloc.first_line);
        }
    | unaryAssignExpr
        {
            $$ = new PTNode(PTNode::EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | simpleExpression
        {
            $$ = new PTNode(PTNode::EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
unaryAssignExpr:
    unaryAssignop mutable
        {
            $$ = new PTNode(PTNode::UNARY_ASSIGN_EXPRESSION,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
    | mutable unaryAssignop
        {
            $$ = new PTNode(PTNode::UNARY_ASSIGN_EXPRESSION,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
;
mutable:
    ID
        {
            $$ = new PTNode(PTNode::ID, yylloc.first_line);
            $$->data.sval = $1;
        }
    | mutable LBRACK expression RBRACK
        {
            $$ = new PTNode(PTNode::MUTABLE,
                std::vector<PTNode*> { $1, $3 }, yylloc.first_line);
        }
;
assignop:
    EQUAL
        {
            $$ = new PTNode(PTNode::EQUAL, yylloc.first_line);
        }
    | PLUSEQUAL
        {
            $$ = new PTNode(PTNode::PLUSEQUAL, yylloc.first_line);
        }
    | MINUSEQUAL
        {
            $$ = new PTNode(PTNode::MINUSEQUAL, yylloc.first_line);
        }
    | TIMESEQUAL
        {
            $$ = new PTNode(PTNode::TIMESEQUAL, yylloc.first_line);
        }
    | DIVEQUAL
        {
            $$ = new PTNode(PTNode::DIVEQUAL, yylloc.first_line);
        }
    | MODEQUAL
        {
            $$ = new PTNode(PTNode::MODEQUAL, yylloc.first_line);
        }
;
unaryAssignop:
    INCR
        {
            $$ = new PTNode(PTNode::INCR, yylloc.first_line);
        }
    | DECR
        {
            $$ = new PTNode(PTNode::DECR, yylloc.first_line);
        }
;
simpleExpression:
    simpleExpression LOGOR andExpression
        {
            PTNode* nLOGOR = new PTNode(PTNode::LOGOR, yylloc.first_line);
            $$ = new PTNode(PTNode::SIMPLE_EXPRESSION,
                std::vector<PTNode*> { $1, nLOGOR, $3 }, yylloc.first_line);
        }
    | andExpression
        {
            $$ = new PTNode(PTNode::SIMPLE_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
andExpression:
    andExpression LOGAND unaryRelExpression
        {
            PTNode* nLOGAND = new PTNode(PTNode::LOGAND, yylloc.first_line);
            $$ = new PTNode(PTNode::AND_EXPRESSION,
                std::vector<PTNode*> { $1, nLOGAND, $3 }, yylloc.first_line);
        }
    | unaryRelExpression
        {
            $$ = new PTNode(PTNode::AND_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
unaryRelExpression:
    NOT unaryRelExpression
        {
            PTNode* nNOT = new PTNode(PTNode::NOT, yylloc.first_line);
            $$ = new PTNode(PTNode::UNARY_REL_EXPRESSION,
                std::vector<PTNode*> { nNOT, $2 }, yylloc.first_line);
        }
    | relExpression
        {
            $$ = new PTNode(PTNode::UNARY_REL_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
relExpression:
    sumExpression relop sumExpression
        {
            $$ = new PTNode(PTNode::REL_EXPRESSION,
                std::vector<PTNode*> { $1, $2, $3 }, yylloc.first_line);
        }
    | sumExpression
        {
            $$ = new PTNode(PTNode::REL_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
relop:
    LE
        {
            $$ = new PTNode(PTNode::LE, yylloc.first_line);
        }
    | LT
        {
            $$ = new PTNode(PTNode::LT, yylloc.first_line);
        }
    | GT
        {
            $$ = new PTNode(PTNode::GT, yylloc.first_line);
        }
    | GE
        {
            $$ = new PTNode(PTNode::GE, yylloc.first_line);
        }
    | ISEQ
        {
            $$ = new PTNode(PTNode::ISEQ, yylloc.first_line);
        }
    | NOTEQ
        {
            $$ = new PTNode(PTNode::NOTEQ, yylloc.first_line);
        }
;
sumExpression:
    sumExpression sumop mulExpression
        {
            $$ = new PTNode(PTNode::SUM_EXPRESSION,
                std::vector<PTNode*> { $1, $2, $3 }, yylloc.first_line);
        }
    | mulExpression
        {
            $$ = new PTNode(PTNode::SUM_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
sumop:
    PLUS
        {
            $$ = new PTNode(PTNode::PLUS, yylloc.first_line);
        }
    | MINUS
        {
            $$ = new PTNode(PTNode::MINUS, yylloc.first_line);
        }
;
mulExpression:
    mulExpression mulop unaryExpression
        {
            $$ = new PTNode(PTNode::MUL_EXPRESSION,
                std::vector<PTNode*> { $1, $2, $3 }, yylloc.first_line);
        }
    | unaryExpression
        {
            $$ = new PTNode(PTNode::MUL_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
mulop:
    TIMES
        {
            $$ = new PTNode(PTNode::TIMES, yylloc.first_line);
        }
    | DIVIDE
        {
            $$ = new PTNode(PTNode::DIVIDE, yylloc.first_line);
        }
    | MODULO
        {
            $$ = new PTNode(PTNode::MODULO, yylloc.first_line);
        }
;
unaryExpression:
    unaryMinus
        {
            $$ = new PTNode(PTNode::UNARY_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | factor
        {
            $$ = new PTNode(PTNode::UNARY_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
unaryMinus:
    MINUS unaryExpression
        {
            $$ = new PTNode(PTNode::UNARY_MINUS,
                std::vector<PTNode*> { $2 }, yylloc.first_line);
        }
;
factor:
    immutable
        {
            $$ = new PTNode(PTNode::FACTOR,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | mutable
        {
            $$ = new PTNode(PTNode::FACTOR,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
immutable:
    LPAREN expression RPAREN
        {
            $$ = new PTNode(PTNode::IMMUTABLE,
                std::vector<PTNode*> { $2 }, yylloc.first_line);
        }
    | call
        {
            $$ = new PTNode(PTNode::IMMUTABLE,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | constant
        {
            $$ = new PTNode(PTNode::IMMUTABLE,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
call:
    ID LPAREN args RPAREN
        {
            PTNode* tID = new PTNode(PTNode::ID, yylloc.first_line);
            tID->data.sval = $1;
            $$ = new PTNode(PTNode::CALL,
                std::vector<PTNode*> { tID, $3 }, yylloc.first_line);
        }
;
args:
    argList
        {
            $$ = new PTNode(PTNode::ARGS,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | %empty
        {
            $$ = new PTNode();
        }
;
argList:
    argList COMMA expression
        {
            $$ = new PTNode(PTNode::ARG_LIST,
                std::vector<PTNode*> { $1, $3 }, yylloc.first_line);
        }
    | expression
        {
            $$ = new PTNode(PTNode::ARG_LIST,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
constant:
    STRINGLIT
        {
            $$ = new PTNode(PTNode::STRINGLIT, yylloc.first_line);
            $$->data.sval = $1;
        }
    | CHARLIT
        {
            $$ = new PTNode(PTNode::CHARLIT, yylloc.first_line);
            $$->data.cval = $1;
        }
    | FLOATCONST
        {
            $$ = new PTNode(PTNode::FLOATCONST, yylloc.first_line);
            $$->data.fval = $1;
        }
    | INTCONST
        {
            $$ = new PTNode(PTNode::INTCONST, yylloc.first_line);
            $$->data.ival = $1;
        }
;
compoundStmt:
    LBRACE localDeclarations statementList RBRACE
        {
            $$ = new PTNode(PTNode::COMPOUND_STMT,
                std::vector<PTNode*> { $2, $3 }, yylloc.first_line);
        }
;
localDeclarations:
    localDeclarations scopedVarDeclaration
        {
            $$ = new PTNode(PTNode::LOCAL_DECLARATIONS,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
    | %empty
        {
            $$ = new PTNode(PTNode::LOCAL_DECLARATIONS, yylloc.first_line);
        }
;
statementList:
    statementList statement
        {
            $$ = new PTNode(PTNode::STATEMENT_LIST,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
    | %empty
        {
            $$ = new PTNode();
        }
;
selectionStmt:
    IF LPAREN simpleExpression RPAREN compoundStmt elseIfList
        {
            PTNode* tIF = new PTNode(PTNode::IF, yylloc.first_line);
            $$ = new PTNode(PTNode::SELECTION_STMT,
                std::vector<PTNode*> { tIF, $3, $5, $6 }, yylloc.first_line);
        }
    | IF LPAREN simpleExpression RPAREN compoundStmt elseIfList elseStmt
        {
            PTNode* tIF = new PTNode(PTNode::IF, yylloc.first_line);
            $$ = new PTNode(PTNode::SELECTION_STMT,
                std::vector<PTNode*> { tIF, $3, $5, $6, $7 }, yylloc.first_line);
        }
;
elseStmt:
    ELSE compoundStmt
        {
            PTNode* tELSE = new PTNode(PTNode::ELSE, yylloc.first_line);
            $$ = new PTNode(PTNode::ELSE_STMT,
                std::vector<PTNode*> { tELSE, $2 }, yylloc.first_line);
        }
;
elseIfList:
    elseIfList ELSE IF LPAREN simpleExpression RPAREN compoundStmt
        {
            PTNode* tELSEIF = new PTNode(PTNode::ELSE_IF, yylloc.first_line);
            $$ = new PTNode(PTNode::ELSE_IF_LIST,
                std::vector<PTNode*> { $1, tELSEIF, $5, $7 }, yylloc.first_line);
        }
    | %empty
        {
            $$ = new PTNode();
        }
;
iterationStmt:
    whileStmt
        {
            $$ = new PTNode(PTNode::ITERATION_STMT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | forStmt
        {
            $$ = new PTNode(PTNode::ITERATION_STMT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
whileStmt:
    WHILE LPAREN simpleExpression RPAREN statement
        {
            $$ = new PTNode(PTNode::WHILE_STMT,
                std::vector<PTNode*> { $3, $5 }, yylloc.first_line);
        }
;
forStmt:
    FOR LPAREN varDeclaration relExpression SEMICOLON expression RPAREN statement
        {
            $$ = new PTNode(PTNode::FOR_STMT,
                std::vector<PTNode*> { $3, $4, $6, $8 }, yylloc.first_line);
        }
;
returnStmt:
    RETURN SEMICOLON
        {
            $$ = new PTNode(PTNode::RETURN_STMT, yylloc.first_line);
        }
    | RETURN expression SEMICOLON
        {
            $$ = new PTNode(PTNode::RETURN_STMT,
                std::vector<PTNode*> { $2 }, yylloc.first_line);
        }
;
breakStmt:
    BREAK SEMICOLON
        {
            PTNode* tBREAK = new PTNode(PTNode::BREAK, yylloc.first_line);
            $$ = new PTNode(PTNode::BREAK_STMT,
                std::vector<PTNode*> { tBREAK }, yylloc.first_line);
        }
;
%%

/**
 * @brief Error function called if one is encountered during parsing
 *
 * @param s Error string
 */
void yyerror(const char *s)
{
	spdlog::error("{} on line {}", s, yylloc.first_line);
	exit(-1);
}