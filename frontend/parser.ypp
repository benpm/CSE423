%{
    #include <vector>
    #include <spdlog/spdlog.h>
    #include <spdlog/sinks/stdout_color_sinks.h>
    #include <spdlog/fmt/fmt.h>
    #include <parsetree.hpp>

    extern int yylex();
    extern int yyparse();
    extern void yyerror(const char *s);

    PTNode* pt;
%}
%locations

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  Initially (by default), yystype
// is merely a typedef of "int", but for non-trivial projects, tokens could
// be of any arbitrary data type.  So, to deal with that, the idea is to
// override yystype's default typedef to be a C union instead.  Unions can
// hold all of the types of tokens that Flex could return, and this this means
// we can return ints or floats or strings cleanly.  Bison implements this
// mechanism with the %union directive:
%union {
    int ival;
    float fval;
    char *sval;
    char cval;
    PTNode* pt;
}

%type <pt> program
%type <pt> declarationList
%type <pt> declaration
%type <pt> varDeclaration
%type <pt> scopedVarDeclaration
%type <pt> varDeclList
%type <pt> varDeclInitialize
%type <pt> varDeclId
%type <pt> scopedTypeSpecifier
%type <pt> typeSpecifier
%type <pt> funDeclaration
%type <pt> funName
%type <pt> params
%type <pt> paramList
%type <pt> paramId
%type <pt> statement
%type <pt> expressionStmt
%type <pt> expression
%type <pt> mutable
%type <pt> assignop
%type <pt> unaryAssignop
%type <pt> simpleExpression
%type <pt> andExpression
%type <pt> unaryRelExpression
%type <pt> relExpression
%type <pt> relop
%type <pt> sumExpression
%type <pt> sumop
%type <pt> mulExpression
%type <pt> mulop
%type <pt> unaryExpression
%type <pt> unaryop
%type <pt> factor
%type <pt> immutable
%type <pt> call
%type <pt> args
%type <pt> argList
%type <pt> constant
%type <pt> compoundStmt
%type <pt> localDeclarations
%type <pt> statementList
%type <pt> selectionStmt
%type <pt> elseIfList
%type <pt> iterationStmt
%type <pt> whileStmt
%type <pt> forStmt
%type <pt> returnStmt
%type <pt> breakStmt

//Terminals
%token <sval> INT
%token <sval> FLOAT
%token <sval> CHAR

%token <sval> FOR
%token <sval> WHILE
%token <sval> IF
%token <sval> ELSE
%token <sval> RETURN
%token <sval> BREAK

%token <cval> SEMICOLON
%token <cval> COMMA
%token <cval> LPAREN
%token <cval> RPAREN
%token <cval> LBRACE
%token <cval> RBRACE
%token <cval> LBRACK
%token <cval> RBRACK
%token <cval> EQUAL
%token <cval> PLUS
%token <cval> MINUS
%token <cval> TIMES
%token <cval> DIVIDE
%token <cval> MODULO
%token <sval> PLUSEQUAL
%token <sval> MINUSEQUAL
%token <sval> TIMESEQUAL
%token <sval> DIVEQUAL
%token <sval> MODEQUAL
%token <sval> INCR
%token <sval> DECR
%token <cval> LT
%token <cval> GT
%token <sval> LE
%token <sval> GE
%token <sval> ISEQ
%token <sval> NOTEQ
%token <sval> LOGAND
%token <sval> LOGOR
%token <cval> NOT

%token <sval> STRINGLIT
%token <cval> CHARLIT
%token <ival> INTCONST
%token <fval> FLOATCONST
%token <sval> ID

%token <sval> UNKNOWN

//Grammar
%%
program:
    declarationList
        {
            pt = new PTNode(PTNode::Label::PROGRAM,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
declarationList:
    declarationList declaration
        {
            $$ = new PTNode(PTNode::Label::DECLARATION_LIST,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
    | declaration
        {
            $$ = new PTNode(PTNode::Label::DECLARATION_LIST,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
declaration:
    varDeclaration
        {
            $$ = new PTNode(PTNode::Label::DECLARATION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | funDeclaration
        {
            $$ = new PTNode(PTNode::Label::DECLARATION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
varDeclaration:
    typeSpecifier varDeclList SEMICOLON
        {
            $$ = new PTNode(PTNode::Label::VAR_DECLARATION,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
;
scopedVarDeclaration:
    scopedTypeSpecifier varDeclList SEMICOLON
        {
            $$ = new PTNode(PTNode::Label::SCOPED_VAR_DECLARATION,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
;
varDeclList:
    varDeclList COMMA varDeclInitialize
        {
            $$ = new PTNode(PTNode::Label::VAR_DECL_LIST,
                std::vector<PTNode*> { $1, $3 }, yylloc.first_line);
        }
    | varDeclInitialize
        {
            $$ = new PTNode(PTNode::Label::VAR_DECL_LIST,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
varDeclInitialize:
    varDeclId
        {
            $$ = new PTNode(PTNode::Label::VAR_DECL_INITIALIZE,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | varDeclId EQUAL simpleExpression
        {
            $$ = new PTNode(PTNode::Label::VAR_DECL_INITIALIZE,
                std::vector<PTNode*> { $1, $3}, yylloc.first_line);
        }
;
varDeclId:
    ID
        {
            $$ = new PTNode(PTNode::Label::ID,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | ID LBRACK RBRACK
        {
            $$ = new PTNode(PTNode::Label::ARRAY_ID,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | ID LBRACK constant RBRACK
        {
            $$ = new PTNode(PTNode::Label::VAR_DECL_ID,
                std::vector<PTNode*> { $3 }, yylloc.first_line);
        }
;
scopedTypeSpecifier:
    typeSpecifier
        {
            $$ = new PTNode(PTNode::Label::SCOPED_TYPE_SPECIFIER,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
typeSpecifier:
    INT
        {
            $$ = new PTNode(PTNode::Label::INT,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | FLOAT
        {
            $$ = new PTNode(PTNode::Label::FLOAT,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | CHAR
        {
            $$ = new PTNode(PTNode::Label::CHAR,
                std::vector<PTNode*>(), yylloc.first_line);
        }
;
funName:
    ID
        {
            $$ = new PTNode(PTNode::Label::ID,
                std::vector<PTNode*>(), yylloc.first_line);
        }
funDeclaration:
    typeSpecifier funName LPAREN params RPAREN statement
        {
            $$ = new PTNode(PTNode::Label::FUN_DECLARATION,
                std::vector<PTNode*> { $1, $2, $4, $6}, yylloc.first_line);
        }
;
params:
    paramList
        {
            $$ = new PTNode(PTNode::Label::PARAMS,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | %empty 
        {
            $$ = new PTNode();
        }
;
paramList:
    paramList COMMA typeSpecifier paramId
        {
            $$ = new PTNode(PTNode::Label::PARAM_LIST,
                std::vector<PTNode*> { $1, $3, $4 }, yylloc.first_line);
        }
    | typeSpecifier paramId
        {
            $$ = new PTNode(PTNode::Label::PARAM_LIST,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
;
paramId:
    ID
        {
            $$ = new PTNode(PTNode::Label::ID,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | ID LBRACK RBRACK
        {
            $$ = new PTNode(PTNode::Label::ID,
                std::vector<PTNode*>(), yylloc.first_line);
        }
;
statement:
    expressionStmt
        {
            $$ = new PTNode(PTNode::Label::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | compoundStmt
        {
            $$ = new PTNode(PTNode::Label::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | selectionStmt
        {
            $$ = new PTNode(PTNode::Label::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | iterationStmt
        {
            $$ = new PTNode(PTNode::Label::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | returnStmt
        {
            $$ = new PTNode(PTNode::Label::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | breakStmt
        {
            $$ = new PTNode(PTNode::Label::STATEMENT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
expressionStmt:
    expression SEMICOLON
        {
            $$ = new PTNode(PTNode::Label::EXPRESSION_STMT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | SEMICOLON
        {
            $$ = new PTNode();
        }
;
expression:
    mutable assignop expression
        {
            $$ = new PTNode(PTNode::Label::EXPRESSION,
                std::vector<PTNode*> { $2, $3 }, yylloc.first_line);
        }
    | unaryAssignop mutable
        {
            $$ = new PTNode(PTNode::Label::EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | mutable unaryAssignop
        {
            $$ = new PTNode(PTNode::Label::EXPRESSION,
                std::vector<PTNode*> { $2 }, yylloc.first_line);
        }
    | simpleExpression
        {
            $$ = new PTNode(PTNode::Label::EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
mutable:
    ID
        {
            $$ = new PTNode(PTNode::Label::ID,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | mutable LBRACK expression RBRACK
        {
            $$ = new PTNode(PTNode::Label::MUTABLE,
                std::vector<PTNode*> { $1, $3 }, yylloc.first_line);
        }
assignop:
    EQUAL
        {
            $$ = new PTNode(PTNode::Label::EQUAL,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | PLUSEQUAL
        {
            $$ = new PTNode(PTNode::Label::PLUSEQUAL,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | MINUSEQUAL
        {
            $$ = new PTNode(PTNode::Label::MINUSEQUAL,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | TIMESEQUAL
        {
            $$ = new PTNode(PTNode::Label::TIMESEQUAL,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | DIVEQUAL
        {
            $$ = new PTNode(PTNode::Label::DIVEQUAL,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | MODEQUAL
        {
            $$ = new PTNode(PTNode::Label::MODEQUAL,
                std::vector<PTNode*>(), yylloc.first_line);
        }
unaryAssignop:
    INCR
        {
            $$ = new PTNode(PTNode::Label::INCR,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | DECR
        {
            $$ = new PTNode(PTNode::Label::DECR,
                std::vector<PTNode*>(), yylloc.first_line);
        }
simpleExpression:
    simpleExpression LOGOR andExpression
        {
            $$ = new PTNode(PTNode::Label::SIMPLE_EXPRESSION,
                std::vector<PTNode*> { $1, $3 }, yylloc.first_line);
        }
    | andExpression
        {
            $$ = new PTNode(PTNode::Label::SIMPLE_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
andExpression:
    andExpression LOGAND unaryRelExpression
        {
            $$ = new PTNode(PTNode::Label::AND_EXPRESSION,
                std::vector<PTNode*> { $1, $3 }, yylloc.first_line);
        }
    | unaryRelExpression
        {
            $$ = new PTNode(PTNode::Label::AND_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
unaryRelExpression:
    NOT unaryRelExpression
        {
            $$ = new PTNode(PTNode::Label::UNARY_REL_EXPRESSION,
                std::vector<PTNode*> { $2 }, yylloc.first_line);
        }
    | relExpression
        {
            $$ = new PTNode(PTNode::Label::UNARY_REL_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
relExpression:
    sumExpression relop sumExpression
        {
            $$ = new PTNode(PTNode::Label::REL_EXPRESSION,
                std::vector<PTNode*> { $1, $2, $3 }, yylloc.first_line);
        }
    | sumExpression
        {
            $$ = new PTNode(PTNode::Label::REL_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
relop:
    LE
        {
            $$ = new PTNode(PTNode::Label::LE,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | LT
        {
            $$ = new PTNode(PTNode::Label::LT,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | GT
        {
            $$ = new PTNode(PTNode::Label::GT,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | GE
        {
            $$ = new PTNode(PTNode::Label::GE,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | ISEQ
        {
            $$ = new PTNode(PTNode::Label::ISEQ,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | NOTEQ
        {
            $$ = new PTNode(PTNode::Label::NOTEQ,
                std::vector<PTNode*>(), yylloc.first_line);
        }
;
sumExpression:
    sumExpression sumop mulExpression
        {
            $$ = new PTNode(PTNode::Label::SUM_EXPRESSION,
                std::vector<PTNode*> { $1, $2, $3 }, yylloc.first_line);
        }
    | mulExpression
        {
            $$ = new PTNode(PTNode::Label::SUM_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
sumop:
    PLUS
        {
            $$ = new PTNode(PTNode::Label::PLUS,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | MINUS
        {
            $$ = new PTNode(PTNode::Label::MINUS,
                std::vector<PTNode*>(), yylloc.first_line);
        }
;
mulExpression:
    mulExpression mulop unaryExpression
        {
            $$ = new PTNode(PTNode::Label::MUL_EXPRESSION,
                std::vector<PTNode*> { $1, $2, $3 }, yylloc.first_line);
        }
    | unaryExpression
        {
            $$ = new PTNode(PTNode::Label::MUL_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
mulop:
    TIMES
        {
            $$ = new PTNode(PTNode::Label::TIMES,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | DIVIDE
        {
            $$ = new PTNode(PTNode::Label::DIVIDE,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | MODULO
        {
            $$ = new PTNode(PTNode::Label::MODULO,
                std::vector<PTNode*>(), yylloc.first_line);
        }
;
unaryExpression:
    unaryop unaryExpression
        {
            $$ = new PTNode(PTNode::Label::UNARY_EXPRESSION,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
    | factor
        {
            $$ = new PTNode(PTNode::Label::UNARY_EXPRESSION,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
unaryop:
    PLUS
        {
            $$ = new PTNode(PTNode::Label::PLUS,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | MINUS
        {
            $$ = new PTNode(PTNode::Label::MINUS,
                std::vector<PTNode*>(), yylloc.first_line);
        }
;
factor:
    immutable
        {
            $$ = new PTNode(PTNode::Label::FACTOR,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | mutable
        {
            $$ = new PTNode(PTNode::Label::FACTOR,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
immutable:
    LPAREN expression RPAREN
        {
            $$ = new PTNode(PTNode::Label::IMMUTABLE,
                std::vector<PTNode*> { $2 }, yylloc.first_line);
        }
    | call
        {
            $$ = new PTNode(PTNode::Label::IMMUTABLE,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | constant
        {
            $$ = new PTNode(PTNode::Label::IMMUTABLE,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
call:
    ID LPAREN args RPAREN
        {
            $$ = new PTNode(PTNode::Label::CALL,
                std::vector<PTNode*> { $3 }, yylloc.first_line);
        }
;
args:
    argList
        {
            $$ = new PTNode(PTNode::Label::ARGS,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | %empty 
        {
            $$ = new PTNode();
        }
;
argList:
    argList COMMA expression
        {
            $$ = new PTNode(PTNode::Label::ARG_LIST,
                std::vector<PTNode*> { $1, $3 }, yylloc.first_line);
        }
    | expression
        {
            $$ = new PTNode(PTNode::Label::ARG_LIST,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
constant:
    STRINGLIT
        {
            $$ = new PTNode(PTNode::Label::STRINGLIT,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | CHARLIT
        {
            $$ = new PTNode(PTNode::Label::CHARLIT,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | FLOATCONST
        {
            $$ = new PTNode(PTNode::Label::FLOATCONST,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | INTCONST
        {
            $$ = new PTNode(PTNode::Label::INTCONST,
                std::vector<PTNode*>(), yylloc.first_line);
        }
;
compoundStmt:
    LBRACE localDeclarations statementList RBRACE
        {
            $$ = new PTNode(PTNode::Label::COMPOUND_STMT,
                std::vector<PTNode*> { $2, $3 }, yylloc.first_line);
        }
;
localDeclarations:
    localDeclarations scopedVarDeclaration
        {
            $$ = new PTNode(PTNode::Label::LOCAL_DECLARATIONS,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
    | %empty 
        {
            $$ = new PTNode();
        }
;
statementList:
    statementList statement
        {
            $$ = new PTNode(PTNode::Label::STATEMENT_LIST,
                std::vector<PTNode*> { $1, $2 }, yylloc.first_line);
        }
    | %empty 
        {
            $$ = new PTNode();
        }
;
selectionStmt:
    IF LPAREN simpleExpression RPAREN compoundStmt elseIfList
        {
            PTNode* ntIF = new PTNode(PTNode::Label::IF,
                std::vector<PTNode*>(), yylloc.first_line);
            $$ = new PTNode(PTNode::Label::SELECTION_STMT,
                std::vector<PTNode*> { ntIF, $3, $5, $6 }, yylloc.first_line);
        }
    | IF LPAREN simpleExpression RPAREN compoundStmt elseIfList ELSE compoundStmt
        {
            PTNode* ntIF = new PTNode(PTNode::Label::IF,
                std::vector<PTNode*>(), yylloc.first_line);
            PTNode* ntELSE = new PTNode(PTNode::Label::ELSE,
                std::vector<PTNode*>(), yylloc.first_line);
            $$ = new PTNode(PTNode::Label::SELECTION_STMT,
                std::vector<PTNode*> { ntIF, $3, $5, $6, ntELSE, $8 }, yylloc.first_line);
        }
;
elseIfList:
    elseIfList ELSE IF LPAREN simpleExpression RPAREN compoundStmt
        {
            PTNode* ntELSE = new PTNode(PTNode::Label::ELSE,
                std::vector<PTNode*>(), yylloc.first_line);
            $$ = new PTNode(PTNode::Label::ELSE_IF_LIST,
                std::vector<PTNode*> { $1, ntELSE, $5, $7 }, yylloc.first_line);
        }
    | %empty 
        {
            $$ = new PTNode();
        }
;
iterationStmt:
    whileStmt
        {
            $$ = new PTNode(PTNode::Label::ITERATION_STMT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
    | forStmt
        {
            $$ = new PTNode(PTNode::Label::ITERATION_STMT,
                std::vector<PTNode*> { $1 }, yylloc.first_line);
        }
;
whileStmt:
    WHILE LPAREN simpleExpression RPAREN statement
        {
            $$ = new PTNode(PTNode::Label::WHILE_STMT,
                std::vector<PTNode*> { $3, $5 }, yylloc.first_line);
        }
;
forStmt:
    FOR LPAREN varDeclaration relExpression SEMICOLON expression RPAREN statement
        {
            $$ = new PTNode(PTNode::Label::FOR_STMT,
                std::vector<PTNode*> { $3, $4, $6, $8 }, yylloc.first_line);
        }
;
returnStmt:
    RETURN SEMICOLON
        {
            $$ = new PTNode(PTNode::Label::RETURN_STMT,
                std::vector<PTNode*>(), yylloc.first_line);
        }
    | RETURN expression SEMICOLON
        {
            $$ = new PTNode(PTNode::Label::RETURN_STMT,
                std::vector<PTNode*> { $2 }, yylloc.first_line);
        }
;
breakStmt:
    BREAK SEMICOLON
        {
            $$ = new PTNode(PTNode::Label::BREAK_STMT,
                std::vector<PTNode*>(), yylloc.first_line);
        }
;
%%
