%{
    #include <cstdio>
    #include <iostream>
    #include <spdlog/spdlog.h>
    #include <spdlog/sinks/stdout_color_sinks.h>
    #include <spdlog/fmt/fmt.h>

    extern int yylex();
    extern int yyparse();
    extern void yyerror(const char *s);
    // https://aquamentus.com/flex_bison.html
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  Initially (by default), yystype
// is merely a typedef of "int", but for non-trivial projects, tokens could
// be of any arbitrary data type.  So, to deal with that, the idea is to
// override yystype's default typedef to be a C union instead.  Unions can
// hold all of the types of tokens that Flex could return, and this this means
// we can return ints or floats or strings cleanly.  Bison implements this
// mechanism with the %union directive:
%union {
    int ival;
    float fval;
    char *sval;
    char cval;
}

//Terminals
%token <sval> INT
%token <sval> FLOAT
%token <sval> CHAR

%token <sval> FOR
%token <sval> WHILE
%token <sval> IF
%token <sval> ELSE
%token <sval> RETURN
%token <sval> BREAK

%token <cval> SEMICOLON
%token <cval> COMMA
%token <cval> LPAREN
%token <cval> RPAREN
%token <cval> LBRACE
%token <cval> RBRACE
%token <cval> LBRACK
%token <cval> RBRACK
%token <cval> EQUAL
%token <cval> PLUS
%token <cval> MINUS
%token <cval> TIMES
%token <cval> DIVIDE
%token <cval> MODULO
%token <sval> PLUSEQUAL
%token <sval> MINUSEQUAL
%token <sval> TIMESEQUAL
%token <sval> DIVEQUAL
%token <sval> MODEQUAL
%token <sval> INCR
%token <sval> DECR
%token <cval> LT
%token <cval> GT
%token <sval> LE
%token <sval> GE
%token <sval> ISEQ
%token <sval> NOTEQ
%token <sval> LOGAND
%token <sval> LOGOR
%token <cval> NOT

%token <sval> STRINGLIT
%token <cval> CHARLIT
%token <ival> INTCONST
%token <fval> FLOATCONST
%token <sval> ID

%token <sval> UNKNOWN

//Grammar
%%
program:
    declarationList { spdlog::info("program found"); }
;
declarationList:
    declarationList declaration { spdlog::debug("declarationList 1 found"); }
    | declaration               { spdlog::debug("declarationList 2 found"); }
;
declaration:
    varDeclaration   { spdlog::debug("declaration 1 found"); }
    | funDeclaration { spdlog::debug("declaration 2 found"); }
;
varDeclaration:
    typeSpecifier varDeclList SEMICOLON { spdlog::debug("varDeclaration found"); }
;
scopedVarDeclaration:
    scopedTypeSpecifier varDeclList SEMICOLON { spdlog::debug("scopedVarDeclaration found"); }
;
varDeclList:
    varDeclList COMMA varDeclInitialize { spdlog::debug("varDeclList 1 found"); }
    | varDeclInitialize                 { spdlog::debug("varDeclList 2 found"); }
;
varDeclInitialize:
    varDeclId                          { spdlog::debug("varDeclInitialize 1 found"); }
    | varDeclId EQUAL simpleExpression { spdlog::debug("varDeclInitialize 2 found"); }
;
varDeclId:
    ID                          { spdlog::debug("varDeclId 1 found: {}", $1);}
    | ID LBRACK RBRACK          { spdlog::debug("varDeclId 2 found: {}", $1);}
    | ID LBRACK INTCONST RBRACK { spdlog::debug("varDeclId 3 found: {}", $1);}
;
scopedTypeSpecifier:
    typeSpecifier { spdlog::debug("scopedTypeSpecifier found"); }
;
typeSpecifier:
    INT     { spdlog::debug("typeSpecifier found: {}", $1); free($1); }
    | FLOAT { spdlog::debug("typeSpecifier found: {}", $1); free($1); }
    | CHAR  { spdlog::debug("typeSpecifier found: {}", $1); free($1); }
;
funDeclaration:
    typeSpecifier ID LPAREN params RPAREN statement { spdlog::debug("funDeclaration found"); }
;
params:
    paramList { spdlog::debug("params 1 found"); }
    | %empty  { spdlog::debug("params 2 found"); }
;
paramList:
    paramList COMMA typeSpecifier paramId { spdlog::debug("paramList 1 found"); }
    | typeSpecifier paramId               { spdlog::debug("paramList 2 found"); }
;
paramId:
    ID                 { spdlog::debug("paramId 1 found: {}", $1); }
    | ID LBRACK RBRACK { spdlog::debug("paramId 2 found: {}", $1); }
;
statement:
    expressionStmt  { spdlog::debug("statement 1 found"); }
    | compoundStmt  { spdlog::debug("statement 2 found"); }
    | selectionStmt { spdlog::debug("statement 3 found"); }
    | iterationStmt { spdlog::debug("statement 4 found"); }
    | returnStmt    { spdlog::debug("statement 5 found"); }
    | breakStmt     { spdlog::debug("statement 6 found"); }
;
expressionStmt:
    expression SEMICOLON { spdlog::debug("expressionStmt 1 found"); }
    | SEMICOLON          { spdlog::debug("expressionStmt 2 found"); }
;
expression:
    ID EQUAL expression        { spdlog::debug("expression 1 found"); }
    | ID PLUSEQUAL expression  { spdlog::debug("expression 2 found"); }
    | ID MINUSEQUAL expression { spdlog::debug("expression 3 found"); }
    | ID TIMESEQUAL expression { spdlog::debug("expression 4 found"); }
    | ID DIVEQUAL expression   { spdlog::debug("expression 5 found"); }
    | ID INCR                  { spdlog::debug("expression 6 found"); }
    | ID DECR                  { spdlog::debug("expression 7 found"); }
    | simpleExpression         { spdlog::debug("expression 8 found"); }
;
simpleExpression:
    simpleExpression LOGOR andExpression { spdlog::debug("simpleExpression 1 found"); }
    | andExpression                      { spdlog::debug("simpleExpression 2 found"); }
;
andExpression:
    andExpression LOGAND unaryRelExpression { spdlog::debug("andExpression 1 found"); }
    | unaryRelExpression                    { spdlog::debug("andExpression 2 found"); }
;
unaryRelExpression:
    NOT unaryRelExpression { spdlog::debug("unaryRelExpression 1 found"); }
    | relExpression        { spdlog::debug("unaryRelExpression 2 found"); }
;
relExpression:
    sumExpression relop sumExpression { spdlog::debug("relExpression 1 found"); }
    | sumExpression                   { spdlog::debug("relExpression 2 found"); }
;
relop:
    LE      { spdlog::debug("relop found: {}", $1); }
    | LT    { spdlog::debug("relop found: {}", $1); }
    | GT    { spdlog::debug("relop found: {}", $1); }
    | GE    { spdlog::debug("relop found: {}", $1); }
    | ISEQ  { spdlog::debug("relop found: {}", $1); }
    | NOTEQ { spdlog::debug("relop found: {}", $1); }
;
sumExpression:
    sumExpression sumop mulExpression { spdlog::debug("sumExpression 1 found"); }
    | mulExpression                   { spdlog::debug("sumExpression 2 found"); }
;
sumop:
    PLUS    { spdlog::debug("sumop found: {}", $1); }
    | MINUS { spdlog::debug("sumpop found: {}", $1); }
;
mulExpression:
    mulExpression mulop unaryExpression { spdlog::debug("mulExpression 1 found"); }
    | unaryExpression                   { spdlog::debug("mulexpression 2 found"); }
;
mulop:
    TIMES    { spdlog::debug("mulop found: {}", $1); }
    | DIVIDE { spdlog::debug("mulop found: {}", $1); }
    | MODULO { spdlog::debug("mulop found: {}", $1); }
;
unaryExpression:
    unaryop unaryExpression { spdlog::debug("unaryExpression 1 found"); }
    | factor                { spdlog::debug("unaryExpression 2 found"); }
;
unaryop:
    PLUS    { spdlog::debug("unaryop found: {}", $1); }
    | MINUS { spdlog::debug("unaryop found: {}", $1); }
    | TIMES { spdlog::debug("unaryop found: {}", $1); }
;
factor:
    immutable { spdlog::debug("factor 1 found"); }
    | ID      { spdlog::debug("factor 2 found: {}", $1); }
;
immutable:
    LPAREN expression RPAREN { spdlog::debug("immutable 1 found"); }
    | call                   { spdlog::debug("immutable 2 found"); }
    | constant               { spdlog::debug("immutable 3 found"); }
;
call:
    ID LPAREN args RPAREN { spdlog::debug("call found: {}", $1); }
;
args:
    argList  { spdlog::debug("args 1 found"); }
    | %empty { spdlog::debug("args 2 found"); }
;
argList:
    argList COMMA expression { spdlog::debug("argList 1 found"); }
    | expression             { spdlog::debug("argList 2 found"); }
;
constant:
    STRINGLIT    { spdlog::debug("STRINGLIT found: {}", $1); free($1); }
    | CHARLIT    { spdlog::debug("CHARLIT found: {}", $1);           }
    | FLOATCONST { spdlog::debug("FLOATCONST found: {}", $1);           }
    | INTCONST   { spdlog::debug("INTCONST found: {}", $1);           }
;
compoundStmt:
    LBRACE localDeclarations statementList RBRACE { spdlog::debug("compoundStmt found"); }
;
localDeclarations:
    localDeclarations scopedVarDeclaration { spdlog::debug("localDeclarations found"); }
    | %empty                               { spdlog::debug("localDeclarations found"); }
;
statementList:
    statementList statement { spdlog::debug("statementList 1 found"); }
    | %empty                { spdlog::debug("statementList 2 found"); }
;
selectionStmt:
    IF LPAREN simpleExpression RPAREN LBRACE statement RBRACE elseIfList { spdlog::debug("selectionStmt 1 found"); }
    | IF LPAREN simpleExpression RPAREN LBRACE statement RBRACE          { spdlog::debug("selectionStmt 2 found"); }
;
elseIfList:
    elseIfList ELSE IF LPAREN simpleExpression RPAREN LBRACE statement RBRACE { spdlog::debug("elseIfList 1 found"); }
    | %empty                                                                  { spdlog::debug("elseIfList 2 found"); }
;
iterationStmt:
    whileStmt { spdlog::debug("iterationStmt 1 found"); }
    | forStmt { spdlog::debug("iterationStmt 2 found"); }
;
whileStmt:
    WHILE LPAREN simpleExpression RPAREN LBRACE statement RBRACE { spdlog::debug("whileStmt found"); }
;
forStmt:
    FOR LPAREN typeSpecifier varDeclList SEMICOLON relExpression SEMICOLON expression RPAREN { spdlog::debug("forStmt found"); }
;
returnStmt:
    RETURN SEMICOLON              { spdlog::debug("returnStmt 1 found"); }
    | RETURN expression SEMICOLON { spdlog::debug("returnStmt 2 found"); }
;
breakStmt:
    BREAK SEMICOLON { spdlog::debug("breakStmt found"); }
;
%%
