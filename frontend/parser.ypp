%{
    #include <vector>
    #include <spdlog/spdlog.h>
    #include <spdlog/sinks/stdout_color_sinks.h>
    #include <spdlog/fmt/fmt.h>
    #include <parsetree.hpp>

    extern int yylex();
    extern int yyparse();
    extern void yyerror(const char *s);

    ParseTree pt;
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  Initially (by default), yystype
// is merely a typedef of "int", but for non-trivial projects, tokens could
// be of any arbitrary data type.  So, to deal with that, the idea is to
// override yystype's default typedef to be a C union instead.  Unions can
// hold all of the types of tokens that Flex could return, and this this means
// we can return ints or floats or strings cleanly.  Bison implements this
// mechanism with the %union directive:
%union {
    int ival;
    float fval;
    char *sval;
    char cval;
    ParseTree pt;
}

%type <pt> program
%type <pt> declarationList
%type <pt> declaration
%type <pt> varDeclaration
%type <pt> scopedVarDeclaration
%type <pt> varDeclList
%type <pt> varDeclInitialize
%type <pt> varDeclId
%type <pt> scopedTypeSpecifier
%type <pt> typeSpecifier
%type <pt> funDeclaration
%type <pt> params
%type <pt> paramList
%type <pt> paramId
%type <pt> statement
%type <pt> expressionStmt
%type <pt> expression
%type <pt> mutable
%type <pt> assignop
%type <pt> unaryAssignop
%type <pt> simpleExpression
%type <pt> andExpression
%type <pt> unaryRelExpression
%type <pt> relExpression
%type <pt> relop
%type <pt> sumExpression
%type <pt> sumop
%type <pt> mulExpression
%type <pt> mulop
%type <pt> unaryExpression
%type <pt> unaryop
%type <pt> factor
%type <pt> immutable
%type <pt> call
%type <pt> args
%type <pt> argList
%type <pt> constant
%type <pt> compoundStmt
%type <pt> localDeclarations
%type <pt> statementList
%type <pt> selectionStmt
%type <pt> elseIfList
%type <pt> iterationStmt
%type <pt> whileStmt
%type <pt> forStmt
%type <pt> returnStmt
%type <pt> breakStmt

//Terminals
%token <sval> INT
%token <sval> FLOAT
%token <sval> CHAR

%token <sval> FOR
%token <sval> WHILE
%token <sval> IF
%token <sval> ELSE
%token <sval> RETURN
%token <sval> BREAK

%token <cval> SEMICOLON
%token <cval> COMMA
%token <cval> LPAREN
%token <cval> RPAREN
%token <cval> LBRACE
%token <cval> RBRACE
%token <cval> LBRACK
%token <cval> RBRACK
%token <cval> EQUAL
%token <cval> PLUS
%token <cval> MINUS
%token <cval> TIMES
%token <cval> DIVIDE
%token <cval> MODULO
%token <sval> PLUSEQUAL
%token <sval> MINUSEQUAL
%token <sval> TIMESEQUAL
%token <sval> DIVEQUAL
%token <sval> MODEQUAL
%token <sval> INCR
%token <sval> DECR
%token <cval> LT
%token <cval> GT
%token <sval> LE
%token <sval> GE
%token <sval> ISEQ
%token <sval> NOTEQ
%token <sval> LOGAND
%token <sval> LOGOR
%token <cval> NOT

%token <sval> STRINGLIT
%token <cval> CHARLIT
%token <ival> INTCONST
%token <fval> FLOATCONST
%token <sval> ID

%token <sval> UNKNOWN

//Grammar
%%
program:
    declarationList
        {
            pt = new Node(Node::Terminal::NONE, Node::NonTerminal::PROGRAM,
                std::vector<ParseTree> { $1 });
        }
;
declarationList:
    declarationList declaration
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::DECLARATION_LIST,
                std::vector<ParseTree> { $1, $2 });
        }
    | declaration
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::DECLARATION_LIST,
                std::vector<ParseTree> { $1 });
        }
;
declaration:
    varDeclaration
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::DECLARATION,
                std::vector<ParseTree> { $1 });
        }
    | funDeclaration
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::DECLARATION,
                std::vector<ParseTree> { $1 });
        }
;
varDeclaration:
    typeSpecifier varDeclList SEMICOLON
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::VAR_DECLARATION,
                std::vector<ParseTree> { $1, $2 });
        }
;
scopedVarDeclaration:
    scopedTypeSpecifier varDeclList SEMICOLON
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::SCOPED_VAR_DECLARATION,
                std::vector<ParseTree> { $1, $2 });
        }
;
varDeclList:
    varDeclList COMMA varDeclInitialize
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::VAR_DECL_LIST,
                std::vector<ParseTree> { $1, $3 });
        }
    | varDeclInitialize
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::VAR_DECL_LIST,
                std::vector<ParseTree> { $1 });
        }
;
varDeclInitialize:
    varDeclId
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::VAR_DECL_INITIALIZE,
                std::vector<ParseTree> { $1 });
        }
    | varDeclId EQUAL simpleExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::VAR_DECL_INITIALIZE,
                std::vector<ParseTree> { $1, $3});
        }
;
varDeclId:
    ID
        {
            $$ = new Node(Node::Terminal::ID, Node::NonTerminal::VAR_DECL_ID,
                std::vector<ParseTree>());
        }
    | ID LBRACK RBRACK
        {
            $$ = new Node(Node::Terminal::ARRAY_ID, Node::NonTerminal::VAR_DECL_ID,
                std::vector<ParseTree>());
        }
    | ID LBRACK constant RBRACK
        {
            $$ = new Node(Node::Terminal::ARRAY_ID, Node::NonTerminal::VAR_DECL_ID,
                std::vector<ParseTree> { $3 });
        }
;
scopedTypeSpecifier:
    typeSpecifier
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::SCOPED_TYPE_SPECIFIER,
                std::vector<ParseTree> { $1 });
        }
;
typeSpecifier:
    INT
        {
            $$ = new Node(Node::Terminal::INT, Node::NonTerminal::TYPE_SPECIFIER,
                std::vector<ParseTree>());
        }
    | FLOAT
        {
            $$ = new Node(Node::Terminal::FLOAT, Node::NonTerminal::TYPE_SPECIFIER,
                std::vector<ParseTree>());
        }
    | CHAR
        {
            $$ = new Node(Node::Terminal::CHAR, Node::NonTerminal::TYPE_SPECIFIER,
                std::vector<ParseTree>());
        }
;
funDeclaration:
    typeSpecifier ID LPAREN params RPAREN statement
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::FUN_DECLARATION,
                std::vector<ParseTree> { $1, $4, $6});
        }
;
params:
    paramList
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::PARAMS,
                std::vector<ParseTree> { $1 });
        }
    | %empty
        {
            $$ = new Node(Node::Terminal::EPSILON, Node::NonTerminal::PARAMS,
                std::vector<ParseTree>());
        }
;
paramList:
    paramList COMMA typeSpecifier paramId
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::PARAM_LIST,
                std::vector<ParseTree> { $1, $3, $4 });
        }
    | typeSpecifier paramId
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::PARAM_LIST,
                std::vector<ParseTree> { $1, $2 });
        }
;
paramId:
    ID
        {
            $$ = new Node(Node::Terminal::ID, Node::NonTerminal::PARAM_ID,
                std::vector<ParseTree>());
        }
    | ID LBRACK RBRACK
        {
            $$ = new Node(Node::Terminal::ARRAY_ID, Node::NonTerminal::PARAM_ID,
                std::vector<ParseTree>());
        }
;
statement:
    expressionStmt
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::STATEMENT,
                std::vector<ParseTree> { $1 });
        }
    | compoundStmt
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::STATEMENT,
                std::vector<ParseTree> { $1 });
        }
    | selectionStmt
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::STATEMENT,
                std::vector<ParseTree> { $1 });
        }
    | iterationStmt
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::STATEMENT,
                std::vector<ParseTree> { $1 });
        }
    | returnStmt
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::STATEMENT,
                std::vector<ParseTree> { $1 });
        }
    | breakStmt
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::STATEMENT,
                std::vector<ParseTree> { $1 });
        }
;
expressionStmt:
    expression SEMICOLON
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::EXPRESSION_STMT,
                std::vector<ParseTree> { $1 });
        }
    | SEMICOLON
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::EXPRESSION_STMT,
                std::vector<ParseTree>());
        }
;
expression:
    mutable assignop expression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::EXPRESSION,
                std::vector<ParseTree> { $2, $3 });
        }
    | unaryAssignop mutable
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::EXPRESSION,
                std::vector<ParseTree> { $1 });
        }
    | mutable unaryAssignop
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::EXPRESSION,
                std::vector<ParseTree> { $2 });
        }
    | simpleExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::EXPRESSION,
                std::vector<ParseTree> { $1 });
        }
;
mutable:
    ID
        {
            $$ = new Node(Node::Terminal::ID, Node::NonTerminal::MUTABLE,
                std::vector<ParseTree>());
        }
    | mutable LBRACK expression RBRACK
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::MUTABLE,
                std::vector<ParseTree> { $1, $3 });
        }
assignop:
    EQUAL
        {
            $$ = new Node(Node::Terminal::EQUAL, Node::NonTerminal::ASSIGN_OP,
                std::vector<ParseTree>());
        }
    | PLUSEQUAL
        {
            $$ = new Node(Node::Terminal::PLUSEQUAL, Node::NonTerminal::ASSIGN_OP,
                std::vector<ParseTree>());
        }
    | MINUSEQUAL
        {
            $$ = new Node(Node::Terminal::MINUSEQUAL, Node::NonTerminal::ASSIGN_OP,
                std::vector<ParseTree>());
        }
    | TIMESEQUAL
        {
            $$ = new Node(Node::Terminal::TIMESEQUAL, Node::NonTerminal::ASSIGN_OP,
                std::vector<ParseTree>());
        }
    | DIVEQUAL
        {
            $$ = new Node(Node::Terminal::DIVEQUAL, Node::NonTerminal::ASSIGN_OP,
                std::vector<ParseTree>());
        }
    | MODEQUAL
        {
            $$ = new Node(Node::Terminal::MODEQUAL, Node::NonTerminal::ASSIGN_OP,
                std::vector<ParseTree>());
        }
unaryAssignop:
    INCR
        {
            $$ = new Node(Node::Terminal::INCR, Node::NonTerminal::UNARY_ASSIGN_OP,
                std::vector<ParseTree>());
        }
    | DECR
        {
            $$ = new Node(Node::Terminal::DECR, Node::NonTerminal::UNARY_ASSIGN_OP,
                std::vector<ParseTree>());
        }
simpleExpression:
    simpleExpression LOGOR andExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::SIMPLE_EXPRESSION,
                std::vector<ParseTree> { $1, $3 });
        }
    | andExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::SIMPLE_EXPRESSION,
                std::vector<ParseTree> { $1 });
        }
;
andExpression:
    andExpression LOGAND unaryRelExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::AND_EXPRESSION,
                std::vector<ParseTree> { $1, $3 });
        }
    | unaryRelExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::AND_EXPRESSION,
                std::vector<ParseTree> { $1 });
        }
;
unaryRelExpression:
    NOT unaryRelExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::UNARY_REL_EXPRESSION,
                std::vector<ParseTree> { $2 });
        }
    | relExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::UNARY_REL_EXPRESSION,
                std::vector<ParseTree> { $1 });
        }
;
relExpression:
    sumExpression relop sumExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::REL_EXPRESSION,
                std::vector<ParseTree> { $1, $2, $3 });
        }
    | sumExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::REL_EXPRESSION,
                std::vector<ParseTree> { $1 });
        }
;
relop:
    LE
        {
            $$ = new Node(Node::Terminal::LE, Node::NonTerminal::REL_OP,
                std::vector<ParseTree>());
        }
    | LT
        {
            $$ = new Node(Node::Terminal::LT, Node::NonTerminal::REL_OP,
                std::vector<ParseTree>());
        }
    | GT
        {
            $$ = new Node(Node::Terminal::GT, Node::NonTerminal::REL_OP,
                std::vector<ParseTree>());
        }
    | GE
        {
            $$ = new Node(Node::Terminal::GE, Node::NonTerminal::REL_OP,
                std::vector<ParseTree>());
        }
    | ISEQ
        {
            $$ = new Node(Node::Terminal::ISEQ, Node::NonTerminal::REL_OP,
                std::vector<ParseTree>());
        }
    | NOTEQ
        {
            $$ = new Node(Node::Terminal::NOTEQ, Node::NonTerminal::REL_OP,
                std::vector<ParseTree>());
        }
;
sumExpression:
    sumExpression sumop mulExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::SUM_EXPRESSION,
                std::vector<ParseTree> { $1, $2, $3 });
        }
    | mulExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::SUM_EXPRESSION,
                std::vector<ParseTree> { $1 });
        }
;
sumop:
    PLUS
        {
            $$ = new Node(Node::Terminal::PLUS, Node::NonTerminal::SUM_OP,
                std::vector<ParseTree>());
        }
    | MINUS
        {
            $$ = new Node(Node::Terminal::MINUS, Node::NonTerminal::SUM_OP,
                std::vector<ParseTree>());
        }
;
mulExpression:
    mulExpression mulop unaryExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::MUL_EXPRESSION,
                std::vector<ParseTree> { $1, $2, $3 });
        }
    | unaryExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::MUL_EXPRESSION,
                std::vector<ParseTree> { $1 });
        }
;
mulop:
    TIMES
        {
            $$ = new Node(Node::Terminal::TIMES, Node::NonTerminal::MUL_OP,
                std::vector<ParseTree>());
        }
    | DIVIDE
        {
            $$ = new Node(Node::Terminal::DIVIDE, Node::NonTerminal::MUL_OP,
                std::vector<ParseTree>());
        }
    | MODULO
        {
            $$ = new Node(Node::Terminal::MODULO, Node::NonTerminal::MUL_OP,
                std::vector<ParseTree>());
        }
;
unaryExpression:
    unaryop unaryExpression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::UNARY_EXPRESSION,
                std::vector<ParseTree> { $1, $2 });
        }
    | factor
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::UNARY_EXPRESSION,
                std::vector<ParseTree> { $1 });
        }
;
unaryop:
    PLUS
        {
            $$ = new Node(Node::Terminal::PLUS, Node::NonTerminal::UNARY_OP,
                std::vector<ParseTree>());
        }
    | MINUS
        {
            $$ = new Node(Node::Terminal::MINUS, Node::NonTerminal::UNARY_OP,
                std::vector<ParseTree>());
        }
;
factor:
    immutable
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::FACTOR,
                std::vector<ParseTree> { $1 });
        }
    | mutable
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::FACTOR,
                std::vector<ParseTree> { $1 });
        }
;
immutable:
    LPAREN expression RPAREN
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::IMMUTABLE,
                std::vector<ParseTree> { $2 });
        }
    | call
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::IMMUTABLE,
                std::vector<ParseTree> { $1 });
        }
    | constant
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::IMMUTABLE,
                std::vector<ParseTree> { $1 });
        }
;
call:
    ID LPAREN args RPAREN
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::CALL,
                std::vector<ParseTree> { $3 });
        }
;
args:
    argList
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::ARGS,
                std::vector<ParseTree> { $1 });
        }
    | %empty
        {
            $$ = new Node(Node::Terminal::EPSILON, Node::NonTerminal::ARGS,
                std::vector<ParseTree>());
        }
;
argList:
    argList COMMA expression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::ARG_LIST,
                std::vector<ParseTree> { $1, $3 });
        }
    | expression
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::ARG_LIST,
                std::vector<ParseTree> { $1 });
        }
;
constant:
    STRINGLIT
        {
            $$ = new Node(Node::Terminal::STRINGLIT, Node::NonTerminal::CONSTANT,
                std::vector<ParseTree>());
        }
    | CHARLIT
        {
            $$ = new Node(Node::Terminal::CHARLIT, Node::NonTerminal::CONSTANT,
                std::vector<ParseTree>());
        }
    | FLOATCONST
        {
            $$ = new Node(Node::Terminal::FLOATCONST, Node::NonTerminal::CONSTANT,
                std::vector<ParseTree>());
        }
    | INTCONST
        {
            $$ = new Node(Node::Terminal::INTCONST, Node::NonTerminal::CONSTANT,
                std::vector<ParseTree>());
        }
;
compoundStmt:
    LBRACE localDeclarations statementList RBRACE
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::COMPOUND_STMT,
                std::vector<ParseTree> { $2, $3 });
        }
;
localDeclarations:
    localDeclarations scopedVarDeclaration
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::LOCAL_DECLARATIONS,
                std::vector<ParseTree> { $1, $2 });
        }
    | %empty
        {
            $$ = new Node(Node::Terminal::EPSILON, Node::NonTerminal::LOCAL_DECLARATIONS,
                std::vector<ParseTree>());
        }
;
statementList:
    statementList statement
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::STATEMENT_LIST,
                std::vector<ParseTree> { $1, $2 });
        }
    | %empty
        {
            $$ = new Node(Node::Terminal::EPSILON, Node::NonTerminal::STATEMENT_LIST,
                std::vector<ParseTree>());
        }
;
selectionStmt:
    IF LPAREN simpleExpression RPAREN compoundStmt elseIfList
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::SELECTION_STMT,
                std::vector<ParseTree> { $3, $5, $6 });
        }
    | IF LPAREN simpleExpression RPAREN compoundStmt elseIfList ELSE compoundStmt
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::SELECTION_STMT,
                std::vector<ParseTree> { $3, $5, $6, $8 });
        }
;
elseIfList:
    elseIfList ELSE IF LPAREN simpleExpression RPAREN compoundStmt
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::ELSE_IF_LIST,
                std::vector<ParseTree> { $1, $5, $7 });
        }
    | %empty
        {
            $$ = new Node(Node::Terminal::EPSILON, Node::NonTerminal::ELSE_IF_LIST,
                std::vector<ParseTree>());
        }
;
iterationStmt:
    whileStmt
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::ITERATION_STMT,
                std::vector<ParseTree> { $1 });
        }
    | forStmt
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::ITERATION_STMT,
                std::vector<ParseTree> { $1 });
        }
;
whileStmt:
    WHILE LPAREN simpleExpression RPAREN statement
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::WHILE_STMT,
                std::vector<ParseTree> { $3, $5 });
        }
;
forStmt:
    FOR LPAREN varDeclaration relExpression SEMICOLON expression RPAREN statement
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::FOR_STMT,
                std::vector<ParseTree> { $3, $4, $6, $8 });
        }
;
returnStmt:
    RETURN SEMICOLON
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::RETURN_STMT,
                std::vector<ParseTree>());
        }
    | RETURN expression SEMICOLON
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::RETURN_STMT,
                std::vector<ParseTree> { $2 });
        }
;
breakStmt:
    BREAK SEMICOLON
        {
            $$ = new Node(Node::Terminal::NONE, Node::NonTerminal::BREAK_STMT,
                std::vector<ParseTree>());
        }
;
%%
