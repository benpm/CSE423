%{
	#include <cstdio>
	#include <iostream>

	extern int yylex();
	extern int yyparse();
	extern void yyerror(const char *s);
	// https://aquamentus.com/flex_bison.html
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  Initially (by default), yystype
// is merely a typedef of "int", but for non-trivial projects, tokens could
// be of any arbitrary data type.  So, to deal with that, the idea is to
// override yystype's default typedef to be a C union instead.  Unions can
// hold all of the types of tokens that Flex could return, and this this means
// we can return ints or floats or strings cleanly.  Bison implements this
// mechanism with the %union directive:
%union {
	int ival;
	float fval;
	char *sval;
	char cval;
}

//Terminals
%token INT
%token FLOAT
%token CHAR

%token <sval> ID
%token <sval> STRINGCONST
%token <ival> INTCONST
%token <fval> FLOATCONST
%token <cval> CHARCONST

//Grammar
%%
typeSpecifier:
	INT   { std::cout << "TYPESPECIFIER found: " << $1 << std::endl; } |
	FLOAT { std::cout << "TYPESPECIFIER found: " << $1 << std::endl; } |
	CHAR  { std::cout << "TYPESPECIFIER found: " << $1 << std::endl; }
;
constant:
	FLOATCONST  { std::cout << "FLOATCONST  found: " << $1 << std::endl; } |
	INTCONST    { std::cout << "INTCONST    found: " << $1 << std::endl; } |
	CHARCONST   { std::cout << "CHARCONST   found: " << $1 << std::endl; } |
	STRINGCONST { std::cout << "STRINGCONST found: " << $1 << std::endl; }
;
%%