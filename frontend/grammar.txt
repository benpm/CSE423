program := declarationList
declarationList := declarationList declaration | declaration
declaration := varDeclaration | funDeclaration
varDeclaration := typeSpecifier varDeclList ;
scopedVarDeclaration := scopedTypeSpecifier varDeclList ;
varDeclList := varDeclList , varDeclInitialize | varDeclInitialize
varDeclInitialize := ID | ID = simpleExpression
scopedTypeSpecifier := typeSpecifier
typeSpecifier := INT | FLOAT | CHAR
funDeclaration := typeSpecifier ID ( params ) statement
params := paramList | eps
paramList := paramList , typeSpecifier ID | typeSpecifier ID
statement := expressionStmt | compoundStmt | selectionStmt | iterationStmt | returnStmt | breakStmt
expressionStmt := expression ; | ;
expression := ID assignop expression | unaryMutOp ID | ID unaryAssignOp | simpleExpression
assignop := = | += | -= | *= | /= | %=
unaryAssignOp := ++ | --
simpleExpression := simpleExpression || andExpression | andExpression
andExpression := andExpression && unaryRelExpression | unaryRelExpression
unaryRelExpression := ! unaryRelExpression | relExpression
relExpression := sumExpression relop sumExpression | sumExpression
relop := <= | < | > | >= | == | !=
sumExpression := sumExpression sumop mulExpression | mulExpression
sumop := + | -
mulExpression := mulExpression mulop unaryExpression | unaryExpression
mulop := * | / | %
unaryExpression := unaryop unaryExpression | factor
unaryop := + | -
factor := immutable | mutable
immutable := ( expression ) | call | constant
call := ID ( args )
args := argList | eps
argList := argList , expression | expression
constant := STRINGLIT | CHARLIT | INTCOST | FLOATCONST
compoundStmt := { localDeclarations statementList }
localDeclarations := localDeclarations scopedVarDeclaration | eps
statementList := statementList statement | eps
selectionStmt := IF ( simpleExpression ) { statement } elseifList | IF ( simpleExpression ) { statement } elsifList else { statement }
elseIfList := elseIfList ELSE IF ( simpleExpression ) { statement } | eps
iterationStmt := whileStmt | forStmt
whileStmt := WHILE ( simpleExpression ) { statement }
forStmt := FOR ( varDeclList ; relExpression ; expression )
returnStmt := return ; | return expression ;
breakStmt := break ;

TERMINALS
_________

INT
FLOAT
CHAR
IF
ELSE
WHILE
FOR
RETURN
;
,
=
-
%
*
+
<=
<
>
>=
==
!=
!
STRINGLIT
CHARLIT
INTCONST
FLOATCONST
ID